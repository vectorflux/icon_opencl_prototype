!>
!!               The module <i>mo_model_import_domain</i>
!! provides functionality to import information about the models computational
!! domain. This information is read from several files that were generated by
!! the patch generator programm. The data types describing the model domain are
!! contained in <i>mo_domain_model</i>.
!!
!! @par Revision History
!!!
!! @par Copyright
!! 2002-2007 by DWD and MPI-M
!! This software is provided for non-commercial use only.
!! See the LICENSE and the WARRANTY conditions.
!!
!! @par License
!! The use of ICON is hereby granted free of charge for an unlimited time,
!! provided the following rules are accepted and applied:
!! <ol>
!! <li> You may use or modify this code for your own non commercial and non
!!    violent purposes.
!! <li> The code may not be re-distributed without the consent of the authors.
!! <li> The copyright notice and statement of authorship must appear in all
!!    copies.
!! <li> You accept the warranty conditions (see WARRANTY).
!! <li> In case you intend to use the code commercially, we oblige you to sign
!!    an according license agreement with DWD and MPI-M.
!! </ol>
!!
!! @par Warranty
!! This code has been tested up to a certain level. Defects and weaknesses,
!! which may be included in the code, do not establish any warranties by the
!! authors.
!! The authors do not make any warranty, express or implied, or assume any
!! liability or responsibility for the use, acquisition or application of this
!! software.
!!
!!
MODULE mo_model_domain_import
!-------------------------------------------------------------------------

USE mo_kind,               ONLY: wp
USE mo_io_units,           ONLY: nnml, nnml_output
USE mo_impl_constants,     ONLY: SUCCESS, &
     &                           MAX_CHAR_LENGTH,  &
     &                           min_rlcell, max_rlcell, &
     &                           min_rledge, max_rledge, &
     &                           min_rlvert, max_rlvert
USE mo_exception
USE mo_model_domain
USE mo_physical_constants, ONLY: omega
USE mo_global_variables,   ONLY: nproma, i_cell_type, patch_file_name, msg_level
USE mo_math_utilities,     ONLY: gvec2cvec, t_cartesian_coordinates
USE mo_math_constants,     ONLY: rad2deg, pi_2
USE mo_namelist,           ONLY: position_nml, POSITIONED
USE mo_loopindices,        ONLY: get_indices_e
USE mo_mpi,                ONLY: p_pe, p_io
USE mo_io_units,           ONLY: filename_max
USE mo_reshape_arrays
USE mo_domain_geometry_methods
USE mo_hyb_params,         ONLY: init_vertical_coord, destruct_vertical_coord
USE mo_interpolation_init, ONLY: construct_int_state, destruct_int_state
USE mo_ext_data,           ONLY: construct_ext_data, destruct_ext_data

IMPLICIT NONE

PRIVATE
#ifdef NOMPI
INCLUDE 'netcdf.inc'
#endif

CHARACTER(len=*), PARAMETER :: version = '$Id$'
!subroutines
PUBLIC :: import_domain, destruct_domain!, &
!         & reshape_int, reshape_real
!-------------------------------------------------------------------------

CONTAINS

!-------------------------------------------------------------------------
!>
SUBROUTINE import_domain

  CALL read_patch(global_patch, patch_file_name)
  global_patch%id = 1
 ! calculate Cartesian components of primal normal
  ! (later these should be provided by the grid generator)
  CALL calculate_cart_normal( global_patch )
  ! Initialize the data for the quadrilateral cells
  ! formed by the two adjacent cells of an edge.
  ! (later this should be provided by the grid generator)
  CALL init_quad_twoadjcells( global_patch )
  CALL init_coriolis( global_patch )

  CALL init_vertical_coord()
  CALL construct_int_state(global_patch, global_patch_int_state)
  
  global_patch_array(1) = global_patch
  global_int_state_array(1) = global_patch_int_state
  CALL construct_ext_data(global_patch_array, global_int_state_array)
  
END SUBROUTINE import_domain
!-------------------------------------------------------------------------

!-------------------------------------------------------------------------
!>
SUBROUTINE destruct_domain

  !-----------------------------------------------------------------------
  CALL destruct_patch(global_patch)
  CALL destruct_vertical_coord()
  CALL destruct_int_state(global_patch_int_state)
  CALL destruct_ext_data()

END SUBROUTINE destruct_domain
!-------------------------------------------------------------------------


!-------------------------------------------------------------------------
SUBROUTINE read_patch( p_patch, patch_file )

CHARACTER(len=*),    INTENT(in)    ::  patch_file   ! name of grid file

TYPE(t_patch), TARGET, INTENT(inout) ::  p_patch      ! patch data structure

INTEGER, ALLOCATABLE :: &
  &  array_c_int(:,:),  &  ! temporary arrays to read in integer values
  &  array_e_int(:,:),  &
  &  array_v_int(:,:)

REAL(wp), ALLOCATABLE :: &
  &  array_c_real(:,:), &  ! temporary arrays to read in real values
  &  array_e_real(:,:), &
  &  array_v_real(:,:)

INTEGER, ALLOCATABLE :: &
  &  array_c_indlist(:,:),  &  ! temporary arrays to read in index lists
  &  array_e_indlist(:,:),  &
  &  array_v_indlist(:,:)

! dummy values for number of internal halo cells, edges, vertices
INTEGER :: n_e_halo_cells
INTEGER :: n_e_halo_edges
INTEGER :: n_e_halo_verts

! INTEGER :: patch_unit

! LOGICAL :: lnetcdf = .TRUE.
! CHARACTER(len=filename_max) :: file

! status variable
INTEGER :: ist

INTEGER :: ncid, dimid, varid
INTEGER :: ji
INTEGER :: jv, jc, je, jvc, jcv, jve, jce, ilv, ibv, ilc, ibc
INTEGER :: icheck, ilev, igrid_level, igrid_id, iparent_id, ipar_id

!-----------------------------------------------------------------------

! set dummy values to zero
n_e_halo_cells = 0
n_e_halo_edges = 0
n_e_halo_verts = 0

ilev = p_patch%level
ipar_id = p_patch%parent_id

!
! start to fill patch type
!

IF (msg_level > 5) THEN
  WRITE(message_text,'(a,a)') 'Read gridmap file ', TRIM(patch_file)
  CALL message ('', TRIM(message_text))
ENDIF

CALL nf(nf_open(TRIM(patch_file), NF_NOWRITE, ncid))
! write(0,*) 'ncid:', ncid

!
! get number of cells, edges and vertices
!
! CALL message ('', 'get number of cells, edges and vertices...')
CALL nf(nf_inq_dimid(ncid, 'cell', dimid))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_inq_dimlen(ncid, dimid, p_patch%n_patch_cells))
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_inq_dimlen(ncid, dimid, p_patch%n_patch_verts))
ENDIF

CALL nf(nf_inq_dimid(ncid, 'edge', dimid))
CALL nf(nf_inq_dimlen(ncid, dimid, p_patch%n_patch_edges))

CALL nf(nf_inq_dimid(ncid, 'vertex', dimid))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_inq_dimlen(ncid, dimid, p_patch%n_patch_verts))
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_inq_dimlen(ncid, dimid, p_patch%n_patch_cells))
ENDIF

!
! calculate and save values for the blocking
!
! ... for the cells
p_patch%nblks_c       = ( p_patch%n_patch_cells + n_e_halo_cells - 1 )  &
  &                   / nproma + 1
p_patch%nblks_int_c   = ( p_patch%n_patch_cells - 1 ) / nproma + 1
p_patch%npromz_int_c  = p_patch%n_patch_cells  &
  &                   - (p_patch%nblks_int_c - 1)*nproma
! total number of cells
p_patch%n_patch_cells = p_patch%n_patch_cells + n_e_halo_cells
p_patch%npromz_c      = p_patch%n_patch_cells - (p_patch%nblks_c - 1)*nproma

! ... for the edges
p_patch%nblks_e       = ( p_patch%n_patch_edges + n_e_halo_edges - 1 )  &
  &                   / nproma + 1
p_patch%nblks_int_e   = ( p_patch%n_patch_edges - 1 ) / nproma + 1
p_patch%npromz_int_e  = p_patch%n_patch_edges  &
  &                   - (p_patch%nblks_int_e - 1)*nproma
! total number of edges
p_patch%n_patch_edges = p_patch%n_patch_edges + n_e_halo_edges
p_patch%npromz_e      = p_patch%n_patch_edges - (p_patch%nblks_e - 1)*nproma

! ... for the vertices
p_patch%nblks_v       = ( p_patch%n_patch_verts + n_e_halo_verts - 1 )  &
  &                   / nproma + 1
p_patch%nblks_int_v   = ( p_patch%n_patch_verts - 1 ) / nproma + 1
p_patch%npromz_int_v  = p_patch%n_patch_verts  &
  &                   - (p_patch%nblks_int_v - 1)*nproma
! total number of vertices
p_patch%n_patch_verts = p_patch%n_patch_verts + n_e_halo_verts
p_patch%npromz_v      = p_patch%n_patch_verts - (p_patch%nblks_v - 1)*nproma

!
! allocate temporary arrays to read in data form the grid/patch generator
!
! integer arrays
ALLOCATE( array_c_int(p_patch%n_patch_cells,6),  &
  &       array_e_int(p_patch%n_patch_edges,6),  &
  &       array_v_int(p_patch%n_patch_verts,6),  &
  &       STAT=ist )
IF (ist /= SUCCESS) THEN
  CALL finish ('mo_model_domain_import:read_patch',  &
    &             'allocation for array_[cev]_int failed')
ENDIF
! real arrays
ALLOCATE( array_c_real(p_patch%n_patch_cells,6),  &
  &       array_e_real(p_patch%n_patch_edges,6),  &
  &       array_v_real(p_patch%n_patch_verts,6),  &
  &       STAT=ist )
IF (ist /= SUCCESS) THEN
  CALL finish ('mo_model_domain_import:read_patch',  &
    &             'allocation for array_[cev]_real failed')
ENDIF
! integer arrays for index lists
ALLOCATE( array_c_indlist(min_rlcell:max_rlcell,global_max_childdom),  &
  &       array_e_indlist(min_rledge:max_rledge,global_max_childdom),  &
  &       array_v_indlist(min_rlvert:max_rlvert,global_max_childdom),  &
  &       STAT=ist )

IF (ist /= SUCCESS) THEN
  CALL finish ('mo_model_domain_import:read_patch',  &
    &          'allocation for array_[cev]_indlist failed')
ENDIF

! Number of global cells/edges/verts
! These are needed for patch allocation
! For a non-divided patch they are identical to the non-global values

p_patch%n_patch_cells_g = p_patch%n_patch_cells
p_patch%n_patch_edges_g = p_patch%n_patch_edges
p_patch%n_patch_verts_g = p_patch%n_patch_verts

!
! Allocate all patch arrays
!
CALL allocate_patch( p_patch )


! p_patch%cells%idx(:,:)
! p_patch%cells%blk(:,:)
CALL nf(nf_inq_varid(ncid, 'cell_index', varid))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1)))
   CALL reshape_idx( array_c_int(:,1), p_patch%nblks_c, p_patch%npromz_c,  &
     &               p_patch%cells%idx(:,:),  &
     &               p_patch%cells%blk(:,:) )
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1)))
   CALL reshape_idx( array_v_int(:,1), p_patch%nblks_v, p_patch%npromz_v,  &
     &               p_patch%verts%idx(:,:),  &
     &               p_patch%verts%blk(:,:) )
ENDIF


! p_patch%cells%neighbor_idx(:,:,:)
! p_patch%cells%neighbor_blk(:,:,:)
! CALL message ('', 'get neighbor_cell_index...')
CALL nf(nf_inq_varid(ncid, 'neighbor_cell_index', varid))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1:3)))
   DO ji = 1, 3
      CALL reshape_idx( array_c_int(:,ji), p_patch%nblks_c, p_patch%npromz_c,  &
        &               p_patch%cells%neighbor_idx(:,:,ji),  &
        &               p_patch%cells%neighbor_blk(:,:,ji) )
   END DO
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1:3)))
   DO ji = 1, 3
     CALL reshape_idx( array_v_int(:,ji), p_patch%nblks_v, p_patch%npromz_v,  &
       &               p_patch%verts%neighbor_idx(:,:,ji),  &
       &               p_patch%verts%neighbor_blk(:,:,ji) )
   END DO
ENDIF

! p_patch%cells%edge_idx(:,:,:)
! p_patch%cells%edge_blk(:,:,:)
CALL nf(nf_inq_varid(ncid, 'edge_of_cell', varid))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1:3)))
   DO ji = 1, 3
     CALL reshape_idx( array_c_int(:,ji), p_patch%nblks_c, p_patch%npromz_c,  &
       &               p_patch%cells%edge_idx(:,:,ji),  &
       &               p_patch%cells%edge_blk(:,:,ji) )
   END DO
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1:3)))
   DO ji = 1, 3
     CALL reshape_idx( array_v_int(:,ji), p_patch%nblks_v, p_patch%npromz_v,  &
       &               p_patch%verts%edge_idx(:,:,ji),  &
       &               p_patch%verts%edge_blk(:,:,ji) )
   END DO
ENDIF

! p_patch%cells%vertex_idx(:,:,:)
! p_patch%cells%vertex_blk(:,:,:)
CALL nf(nf_inq_varid(ncid, 'vertex_of_cell', varid))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1:3)))
   DO ji = 1, 3
     CALL reshape_idx( array_c_int(:,ji), p_patch%nblks_c, p_patch%npromz_c,  &
       &               p_patch%cells%vertex_idx(:,:,ji),  &
       &               p_patch%cells%vertex_blk(:,:,ji) )
   END DO
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1:3)))
   DO ji = 1, 3
     CALL reshape_idx( array_v_int(:,ji), p_patch%nblks_v, p_patch%npromz_v,  &
       &               p_patch%verts%cell_idx(:,:,ji),  &
       &               p_patch%verts%cell_blk(:,:,ji) )
   END DO
ENDIF


! p_patch%cells%edge_orientation(:,:,:)
CALL nf(nf_inq_varid(ncid, 'orientation_of_normal', varid))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1:3)))
   DO ji = 1, 3
     CALL reshape_real( REAL(array_c_int(:,ji),wp),            &
                      & p_patch%nblks_c, p_patch%npromz_c,     &
                      & p_patch%cells%edge_orientation(:,:,ji) )
   END DO
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1:3)))
   DO ji = 1, 3
     CALL reshape_real( REAL(array_v_int(:,ji),wp),            &
                      & p_patch%nblks_v, p_patch%npromz_v,     &
                      & p_patch%verts%edge_orientation(:,:,ji) )
   END DO
ENDIF

! p_patch%cells%center(:,:)%lon
CALL nf(nf_inq_varid(ncid, 'lon_cell_centre', varid))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_double(ncid, varid, array_c_real(:,1)))
   CALL reshape_real( array_c_real(:,1), p_patch%nblks_c, p_patch%npromz_c,  &
     &                p_patch%cells%center(:,:)%lon )
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_double(ncid, varid, array_v_real(:,1)))
   CALL reshape_real( array_v_real(:,1), p_patch%nblks_v, p_patch%npromz_v,  &
     &                p_patch%verts%vertex(:,:)%lon )
ENDIF

! p_patch%cells%center(:,:)%lat
CALL nf(nf_inq_varid(ncid, 'lat_cell_centre', varid))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_double(ncid, varid, array_c_real(:,1)))
   CALL reshape_real( array_c_real(:,1), p_patch%nblks_c, p_patch%npromz_c,  &
     &                p_patch%cells%center(:,:)%lat )
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_double(ncid, varid, array_v_real(:,1)))
   CALL reshape_real( array_v_real(:,1), p_patch%nblks_v, p_patch%npromz_v,  &
     &                p_patch%verts%vertex(:,:)%lat )
ENDIF

! p_patch%cells%area(:,:)
CALL nf(nf_inq_varid(ncid, 'cell_area_p', varid))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_double(ncid, varid, array_c_real(:,1)))
   CALL reshape_real( array_c_real(:,1), p_patch%nblks_c, p_patch%npromz_c,  &
     &                p_patch%cells%area(:,:) )
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_double(ncid, varid, array_v_real(:,1)))
   CALL reshape_real( array_v_real(:,1), p_patch%nblks_v, p_patch%npromz_v,  &
     &                p_patch%verts%dual_area(:,:) )
ENDIF


! p_patch%cells%start_idx(:,:)
! p_patch%cells%start_blk(:,:)
! p_patch%cells%end_idx(:,:)
! p_patch%cells%end_blk(:,:)

!----------------------------------------------------
CALL nf(nf_inq_varid(ncid, 'start_idx_c', varid))
IF (i_cell_type == 3) THEN ! triangular grid
  CALL nf(nf_get_var_int(ncid, varid, array_c_indlist(:,:)))
  CALL reshape_idx_list( array_c_indlist,                                &
   &                    p_patch%cells%start_idx, p_patch%cells%start_blk )
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
  CALL nf(nf_get_var_int(ncid, varid, array_v_indlist(:,:)))
  CALL reshape_idx_list( array_v_indlist,                                &
   &                    p_patch%verts%start_idx, p_patch%verts%start_blk )
ENDIF
!----------------------------------------------------
CALL nf(nf_inq_varid(ncid, 'end_idx_c', varid))
IF (i_cell_type == 3) THEN ! triangular grid
  CALL nf(nf_get_var_int(ncid, varid, array_c_indlist(:,:)))
  CALL reshape_idx_list( array_c_indlist,                                &
   &                    p_patch%cells%end_idx, p_patch%cells%end_blk )
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
  CALL nf(nf_get_var_int(ncid, varid, array_v_indlist(:,:)))
  CALL reshape_idx_list( array_v_indlist,                                &
   &                    p_patch%verts%end_idx, p_patch%verts%end_blk )
ENDIF

! p_patch%edges%idx(:,:)
! p_patch%edges%blk(:,:)
CALL nf(nf_inq_varid(ncid, 'edge_index', varid))
CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1)))
CALL reshape_idx( array_e_int(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
  &               p_patch%edges%idx(:,:),  &
  &               p_patch%edges%blk(:,:) )

!----------------------------------------------------
! CALL message ('', 'nf_close(ncid)...')
! write(0,*) 'ncid:', ncid
! CALL nf(nf_close(ncid))
! CALL message ('', 'nf_close(ncid) done')
! STOP
!----------------------------------------------------


! p_patch%edges%cell_idx(:,:,:)
! p_patch%edges%cell_blk(:,:,:)
CALL nf(nf_inq_varid(ncid, 'adjacent_cell_of_edge', varid))
CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1:2)))
IF (i_cell_type == 3) THEN ! triangular grid
  DO ji = 1, 2
    CALL reshape_idx( array_e_int(:,ji), p_patch%nblks_e, p_patch%npromz_e,  &
      &               p_patch%edges%cell_idx(:,:,ji),  &
      &               p_patch%edges%cell_blk(:,:,ji) )
  END DO
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
  DO ji = 1, 2
    CALL reshape_idx( array_e_int(:,ji), p_patch%nblks_e, p_patch%npromz_e,  &
      &               p_patch%edges%vertex_idx(:,:,ji),  &
      &               p_patch%edges%vertex_blk(:,:,ji) )
  END DO
ENDIF

! p_patch%edges%vertex_idx(:,:,:)
! p_patch%edges%vertex_blk(:,:,:)
CALL nf(nf_inq_varid(ncid, 'edge_vertices', varid))
CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1:2)))
IF (i_cell_type == 3) THEN ! triangular grid
  DO ji = 1, 2
    CALL reshape_idx( array_e_int(:,ji), p_patch%nblks_e, p_patch%npromz_e,  &
      &               p_patch%edges%vertex_idx(:,:,ji),  &
      &               p_patch%edges%vertex_blk(:,:,ji) )
  END DO
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
  DO ji = 1, 2
    CALL reshape_idx( array_e_int(:,ji), p_patch%nblks_e, p_patch%npromz_e,  &
      &               p_patch%edges%cell_idx(:,:,ji),  &
      &               p_patch%edges%cell_blk(:,:,ji) )
  END DO
ENDIF

! p_patch%edges%system_orientation(:,:)
CALL nf(nf_inq_varid(ncid, 'edge_system_orientation', varid))
CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1)))
CALL reshape_real( REAL(array_e_int(:,1),wp),            &
                 & p_patch%nblks_e, p_patch%npromz_e,    &
                 & p_patch%edges%system_orientation(:,:) )

! p_patch%edges%center(:,:)%lon
CALL nf(nf_inq_varid(ncid, 'lon_edge_centre', varid))
CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
  &                p_patch%edges%center(:,:)%lon )

! p_patch%edges%center(:,:)%lat
CALL nf(nf_inq_varid(ncid, 'lat_edge_centre', varid))
CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
  &                p_patch%edges%center(:,:)%lat )

! p_patch%edges%primal_normal(:,:)%v1
CALL nf(nf_inq_varid(ncid, 'zonal_normal_primal_edge', varid))
CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%primal_normal(:,:)%v1 )
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%dual_normal(:,:)%v1 )
ENDIF

! p_patch%edges%primal_normal(:,:)%v2
CALL nf(nf_inq_varid(ncid, 'meridional_normal_primal_edge', varid))
CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%primal_normal(:,:)%v2 )
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%dual_normal(:,:)%v2 )
ENDIF

! p_patch%edges%dual_normal(:,:)%v1
CALL nf(nf_inq_varid(ncid, 'zonal_normal_dual_edge', varid))
CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%dual_normal(:,:)%v1 )
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%primal_normal(:,:)%v1 )
ENDIF

! p_patch%edges%dual_normal(:,:)%v2
CALL nf(nf_inq_varid(ncid, 'meridional_normal_dual_edge', varid))
CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%dual_normal(:,:)%v2 )
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%primal_normal(:,:)%v2 )
ENDIF

! p_patch%edges%primal_edge_length(:,:)
CALL nf(nf_inq_varid(ncid, 'edge_length', varid))
CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%primal_edge_length(:,:) )
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%dual_edge_length(:,:) )
ENDIF

! p_patch%edges%dual_edge_length(:,:)
CALL nf(nf_inq_varid(ncid, 'dual_edge_length', varid))
CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%dual_edge_length(:,:) )
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%primal_edge_length(:,:) )
ENDIF

! p_patch%edges%edge_vert_length(:,:)
CALL nf(nf_inq_varid(ncid, 'edge_vert_distance', varid))
CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1:2)))
IF (i_cell_type == 3) THEN ! triangular grid
   DO ji = 1, 2
     CALL reshape_real( array_e_real(:,ji), p_patch%nblks_e, p_patch%npromz_e, &
       &                p_patch%edges%edge_vert_length(:,:,ji) )
   ENDDO
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   DO ji = 1, 2
     CALL reshape_real( array_e_real(:,ji), p_patch%nblks_e, p_patch%npromz_e, &
       &                p_patch%edges%edge_cell_length(:,:,ji) )
   ENDDO
ENDIF

! p_patch%edges%edge_cell_length(:,:)
CALL nf(nf_inq_varid(ncid, 'edge_cell_distance', varid))
CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1:2)))
IF (i_cell_type == 3) THEN ! triangular grid
   DO ji = 1, 2
     CALL reshape_real( array_e_real(:,ji), p_patch%nblks_e, p_patch%npromz_e, &
       &                p_patch%edges%edge_cell_length(:,:,ji) )
   ENDDO
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   DO ji = 1, 2
     CALL reshape_real( array_e_real(:,ji), p_patch%nblks_e, p_patch%npromz_e, &
       &                p_patch%edges%edge_vert_length(:,:,ji) )
   ENDDO
ENDIF

! p_patch%edges%refin_ctrl(:,:)
CALL nf(nf_inq_varid(ncid, 'refin_e_ctrl', varid))
CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1)))
CALL reshape_int( array_e_int(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
  &               p_patch%edges%refin_ctrl(:,:) )

! p_patch%edges%start_idx(:,:)
! p_patch%edges%start_blk(:,:)
! p_patch%edges%end_idx(:,:)
! p_patch%edges%end_blk(:,:)
CALL nf(nf_inq_varid(ncid, 'start_idx_e', varid))
CALL nf(nf_get_var_int(ncid, varid, array_e_indlist(:,:)))
CALL reshape_idx_list( array_e_indlist,                                &
  &                    p_patch%edges%start_idx, p_patch%edges%start_blk )
CALL nf(nf_inq_varid(ncid, 'end_idx_e', varid))
CALL nf(nf_get_var_int(ncid, varid, array_e_indlist(:,:)))
CALL reshape_idx_list( array_e_indlist,                                &
  &                    p_patch%edges%end_idx, p_patch%edges%end_blk )

! p_patch%verts%idx(:,:)
! p_patch%verts%blk(:,:)
CALL nf(nf_inq_varid(ncid, 'vertex_index', varid))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1)))
   CALL reshape_idx( array_v_int(:,1), p_patch%nblks_v, p_patch%npromz_v,  &
     &               p_patch%verts%idx(:,:),  &
     &               p_patch%verts%blk(:,:) )
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1)))
   CALL reshape_idx( array_c_int(:,1), p_patch%nblks_c, p_patch%npromz_c,  &
     &               p_patch%cells%idx(:,:),  &
     &               p_patch%cells%blk(:,:) )
ENDIF

! p_patch%verts%neighbor_idx(:,:,:)
! p_patch%verts%neighbor_blk(:,:,:)
CALL nf(nf_inq_varid(ncid, 'vertices_of_vertex', varid))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1:6)))
   DO ji = 1, 6
     CALL reshape_idx( array_v_int(:,ji), p_patch%nblks_v, p_patch%npromz_v,  &
       &               p_patch%verts%neighbor_idx(:,:,ji),  &
       &               p_patch%verts%neighbor_blk(:,:,ji) )
   END DO
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1:6)))
   DO ji = 1, 6
     CALL reshape_idx( array_c_int(:,ji), p_patch%nblks_c, p_patch%npromz_c,  &
       &               p_patch%cells%neighbor_idx(:,:,ji),  &
       &               p_patch%cells%neighbor_blk(:,:,ji) )
   END DO
   !
   ! account for dummy edges arising in case of a pentagon
   !
   DO jc = 1, p_patch%n_patch_cells
     DO ji = 1, 6
       IF ( array_c_int(jc,ji) == 0 ) THEN
         ibc = ( jc - 1 ) / nproma + 1
         ilc = jc - ( ibc - 1 )*nproma
         IF ( ji /= 6 ) THEN
           p_patch%cells%neighbor_idx(ilc,ibc,ji) =  &
             &  p_patch%cells%neighbor_idx(ilc,ibc,6)
           p_patch%cells%neighbor_blk(ilc,ibc,ji) =  &
             &  p_patch%cells%neighbor_blk(ilc,ibc,6)
         END IF
         ! Fill dummy neighbor with an existing index to simplify do loops
         ! Note, however, that related multiplication factors must be zero
         p_patch%cells%neighbor_idx(ilc,ibc,6) = p_patch%cells%neighbor_idx(ilc,ibc,5)
         p_patch%cells%neighbor_blk(ilc,ibc,6) = p_patch%cells%neighbor_blk(ilc,ibc,5)
       END IF
     END DO
   END DO
ENDIF

! p_patch%verts%cell_idx(:,:,:)
! p_patch%verts%cell_blk(:,:,:)
CALL nf(nf_inq_varid(ncid, 'cells_of_vertex', varid))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1:6)))
   DO ji = 1, 6
     CALL reshape_idx( array_v_int(:,ji), p_patch%nblks_v, p_patch%npromz_v,  &
       &               p_patch%verts%cell_idx(:,:,ji),  &
       &               p_patch%verts%cell_blk(:,:,ji) )
   END DO
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1:6)))
   DO ji = 1, 6
     CALL reshape_idx( array_c_int(:,ji), p_patch%nblks_c, p_patch%npromz_c,  &
       &               p_patch%cells%vertex_idx(:,:,ji),  &
       &               p_patch%cells%vertex_blk(:,:,ji) )
   END DO
ENDIF

!
! account for dummy cells arising in case of a pentagon
!
IF (i_cell_type == 3) THEN ! triangular grid
  DO jv = 1, p_patch%n_patch_verts
    DO jvc = 1, 6
      IF ( array_v_int(jv,jvc) == 0 ) THEN
        ibv = ( jv - 1 ) / nproma + 1
        ilv = jv - ( ibv - 1 )*nproma
        IF ( jvc /= 6 ) THEN
          p_patch%verts%cell_idx(ilv,ibv,jvc) =  &
            &  p_patch%verts%cell_idx(ilv,ibv,6)
          p_patch%verts%cell_blk(ilv,ibv,jvc) =  &
            &  p_patch%verts%cell_blk(ilv,ibv,6)
        END IF
        ! Fill dummy edge with existing index to simplify do loops
        ! Note, however, that related multiplication factors must be zero
        p_patch%verts%cell_idx(ilv,ibv,6) = p_patch%verts%cell_idx(ilv,ibv,5)
        p_patch%verts%cell_blk(ilv,ibv,6) = p_patch%verts%cell_blk(ilv,ibv,5)
      END IF
    END DO
  END DO
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
  DO jc = 1, p_patch%n_patch_cells
    DO jcv = 1, 6
      IF ( array_c_int(jc,jcv) == 0 ) THEN
        ibc = ( jc - 1 ) / nproma + 1
        ilc = jc - ( ibc - 1 )*nproma
        IF ( jcv /= 6 ) THEN
          p_patch%cells%vertex_idx(ilc,ibc,jcv) =  &
            &  p_patch%cells%vertex_idx(ilc,ibc,6)
          p_patch%cells%vertex_blk(ilc,ibc,jcv) =  &
            &  p_patch%cells%vertex_blk(ilc,ibc,6)
        END IF
        ! Fill dummy edge with existing index to simplify do loops
        ! Note, however, that related multiplication factors must be zero
        p_patch%cells%vertex_idx(ilc,ibc,6) = p_patch%cells%vertex_idx(ilc,ibc,5)
        p_patch%cells%vertex_blk(ilc,ibc,6) = p_patch%cells%vertex_blk(ilc,ibc,5)
      END IF
    END DO
  END DO
ENDIF

! p_patch%verts%edge_idx(:,:,:)
! p_patch%verts%edge_blk(:,:,:)
CALL nf(nf_inq_varid(ncid, 'edges_of_vertex', varid))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1:6)))
   DO ji = 1, 6
     CALL reshape_idx( array_v_int(:,ji), p_patch%nblks_v, p_patch%npromz_v,  &
       &               p_patch%verts%edge_idx(:,:,ji),  &
       &               p_patch%verts%edge_blk(:,:,ji) )
   END DO
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1:6)))
   DO ji = 1, 6
     CALL reshape_idx( array_c_int(:,ji), p_patch%nblks_c, p_patch%npromz_c,  &
       &               p_patch%cells%edge_idx(:,:,ji),  &
       &               p_patch%cells%edge_blk(:,:,ji) )
   END DO
ENDIF


!
! initialize verts%num_edges to 6
!
IF (i_cell_type == 3) THEN ! triangular grid
   p_patch%cells%num_edges(:,:) = 3
   p_patch%verts%num_edges(:,:) = 6
   !
   ! account for dummy edges arising in case of a pentagon
   ! JF:  useful to provide verts%num_edges via grid/patch generator?!
   !
   DO jv = 1, p_patch%n_patch_verts
     DO jve = 1, 6
       IF ( array_v_int(jv,jve) == 0 ) THEN
         ibv = ( jv - 1 ) / nproma + 1
         ilv = jv - ( ibv - 1 )*nproma
         IF ( jve /= 6 ) THEN
           p_patch%verts%edge_idx(ilv,ibv,jve) =  &
             &  p_patch%verts%edge_idx(ilv,ibv,6)
           p_patch%verts%edge_blk(ilv,ibv,jve) =  &
             &  p_patch%verts%edge_blk(ilv,ibv,6)
         END IF
         ! Fill dummy edge with existing index to simplify do loops
         ! Note, however, that related multiplication factors must be zero
         p_patch%verts%edge_idx(ilv,ibv,6) = p_patch%verts%edge_idx(ilv,ibv,5)
         p_patch%verts%edge_blk(ilv,ibv,6) = p_patch%verts%edge_blk(ilv,ibv,5)
         ! set num_edges to 5
         p_patch%verts%num_edges(ilv,ibv) = 5
       END IF
     END DO
   END DO
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   p_patch%verts%num_edges(:,:) = 3
   p_patch%cells%num_edges(:,:) = 6
   !
   ! account for dummy edges arising in case of a pentagon
   !
   DO jc = 1, p_patch%n_patch_cells
     DO jce = 1, 6
       IF ( array_c_int(jc,jce) == 0 ) THEN
         ibc = ( jc - 1 ) / nproma + 1
         ilc = jc - ( ibc - 1 )*nproma
         IF ( jce /= 6 ) THEN
           p_patch%cells%edge_idx(ilc,ibc,jce) =  &
             &  p_patch%cells%edge_idx(ilc,ibc,6)
           p_patch%cells%edge_blk(ilc,ibc,jce) =  &
             &  p_patch%cells%edge_blk(ilc,ibc,6)
         END IF
         ! Fill dummy edge with existing index to simplify do loops
         ! Note, however, that related multiplication factors must be zero
         p_patch%cells%edge_idx(ilc,ibc,6) = p_patch%cells%edge_idx(ilc,ibc,5)
         p_patch%cells%edge_blk(ilc,ibc,6) = p_patch%cells%edge_blk(ilc,ibc,5)
         ! set num_edges to 5
         p_patch%cells%num_edges(ilc,ibc) = 5
       END IF
     END DO
   END DO
ENDIF

! p_patch%verts%edge_orientation(:,:,:)
CALL nf(nf_inq_varid(ncid, 'edge_orientation', varid))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1:6)))
   DO ji = 1, 6
     CALL reshape_real( REAL(array_v_int(:,ji),wp),            &
                      & p_patch%nblks_v, p_patch%npromz_v,     &
                      & p_patch%verts%edge_orientation(:,:,ji) )
   END DO
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1:6)))
   DO ji = 1, 6
     CALL reshape_real( REAL(array_c_int(:,ji),wp),            &
                      & p_patch%nblks_c, p_patch%npromz_c,     &
                      & p_patch%cells%edge_orientation(:,:,ji) )
   END DO
ENDIF

!
! set edge orientation of dummy edges to zero
!
IF (i_cell_type == 3) THEN ! triangular grid
   !
   DO jv = 1, p_patch%n_patch_verts
     DO jve = 1, 6
       IF ( array_v_int(jv,jve) == 0 ) THEN
         ibv = ( jv - 1 ) / nproma + 1
         ilv = jv - ( ibv - 1 )*nproma
         IF ( jve /= 6 ) THEN
           p_patch%verts%edge_orientation(ilv,ibv,jve) =  &
             &  p_patch%verts%edge_orientation(ilv,ibv,6)
         END IF
         p_patch%verts%edge_orientation(ilv,ibv,6) = 0._wp
       END IF
     END DO
   END DO
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   !
   DO jc = 1, p_patch%n_patch_cells
     DO jce = 1, 6
       IF ( array_c_int(jc,jce) == 0 ) THEN
         ibc = ( jc - 1 ) / nproma + 1
         ilc = jc - ( ibc - 1 )*nproma
         IF ( jce /= 6 ) THEN
           p_patch%cells%edge_orientation(ilc,ibc,jce) =  &
             &  p_patch%cells%edge_orientation(ilc,ibc,6)
         END IF
         p_patch%cells%edge_orientation(ilc,ibc,6) = 0._wp
       END IF
     END DO
   END DO
ENDIF

! p_patch%verts%vertex(:,:)%lon
CALL nf(nf_inq_varid(ncid, 'longitude_vertices', varid))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_double(ncid, varid, array_v_real(:,1)))
   CALL reshape_real( array_v_real(:,1), p_patch%nblks_v, p_patch%npromz_v,  &
     &                p_patch%verts%vertex(:,:)%lon )
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_double(ncid, varid, array_c_real(:,1)))
   CALL reshape_real( array_c_real(:,1), p_patch%nblks_c, p_patch%npromz_c,  &
     &                p_patch%cells%center(:,:)%lon )
ENDIF

! p_patch%verts%vertex(:,:)%lat
CALL nf(nf_inq_varid(ncid, 'latitude_vertices', varid))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_double(ncid, varid, array_v_real(:,1)))
   CALL reshape_real( array_v_real(:,1), p_patch%nblks_v, p_patch%npromz_v,  &
     &                p_patch%verts%vertex(:,:)%lat )
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_double(ncid, varid, array_c_real(:,1)))
   CALL reshape_real( array_c_real(:,1), p_patch%nblks_c, p_patch%npromz_c,  &
     &                p_patch%cells%center(:,:)%lat )
ENDIF

! p_patch%verts%dual_area(:,:)
CALL nf(nf_inq_varid(ncid, 'dual_area_p', varid))
IF (i_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_double(ncid, varid, array_v_real(:,1)))
   CALL reshape_real( array_v_real(:,1), p_patch%nblks_v, p_patch%npromz_v,  &
     &                p_patch%verts%dual_area(:,:) )
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_double(ncid, varid, array_c_real(:,1)))
   CALL reshape_real( array_c_real(:,1), p_patch%nblks_c, p_patch%npromz_c,  &
     &                p_patch%cells%area(:,:) )
ENDIF

! p_patch%verts%refin_ctrl(:,:)
! CALL nf(nf_inq_varid(ncid, 'refin_v_ctrl', varid))
! IF (i_cell_type == 3) THEN ! triangular grid
!    CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1)))
!    CALL reshape_int( array_v_int(:,1), p_patch%nblks_v, p_patch%npromz_v,  &
!      &               p_patch%verts%refin_ctrl(:,:) )
! ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
!    CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1)))
!    CALL reshape_int( array_c_int(:,1), p_patch%nblks_c, p_patch%npromz_c,  &
!      &               p_patch%cells%refin_ctrl(:,:) )
! ENDIF
! p_patch%verts%start_idx(:,:)
! p_patch%verts%start_blk(:,:)
! p_patch%verts%end_idx(:,:)
! p_patch%verts%end_blk(:,:)
CALL nf(nf_inq_varid(ncid, 'start_idx_v', varid))
IF (i_cell_type == 3) THEN ! triangular grid
  CALL nf(nf_get_var_int(ncid, varid, array_v_indlist(:,:)))
  CALL reshape_idx_list( array_v_indlist,                                &
   &                    p_patch%verts%start_idx, p_patch%verts%start_blk )
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
  CALL nf(nf_get_var_int(ncid, varid, array_c_indlist(:,:)))
  CALL reshape_idx_list( array_c_indlist,                                &
   &                    p_patch%cells%start_idx, p_patch%cells%start_blk )
ENDIF
CALL nf(nf_inq_varid(ncid, 'end_idx_v', varid))
IF (i_cell_type == 3) THEN ! triangular grid
  CALL nf(nf_get_var_int(ncid, varid, array_v_indlist(:,:)))
  CALL reshape_idx_list( array_v_indlist,                                &
   &                    p_patch%verts%end_idx, p_patch%verts%end_blk )
ELSEIF (i_cell_type == 6) THEN ! hexagonal grid
  CALL nf(nf_get_var_int(ncid, varid, array_c_indlist(:,:)))
  CALL reshape_idx_list( array_c_indlist,                                &
   &                    p_patch%cells%end_idx, p_patch%cells%end_blk )
ENDIF

CALL nf(nf_close(ncid))
! CALL message ('', 'nf_close(ncid) done')


!
! deallocate temporary arrays to read in data form the grid/patch generator
!
! integer arrays
DEALLOCATE( array_c_int, array_e_int, array_v_int,  &
  &         STAT=ist )
IF (ist /= SUCCESS) THEN
  CALL finish ('mo_model_domain_import:read_patch',  &
    &             'deallocation for array_[cev]_int failed')
ENDIF
! real arrays
DEALLOCATE( array_c_real, array_e_real, array_v_real,  &
  &         STAT=ist )
IF (ist /= SUCCESS) THEN
  CALL finish ('mo_model_domain_import:read_patch',  &
    &             'deallocation for array_[cev]_real failed')
ENDIF
! index lists arrays
DEALLOCATE( array_c_indlist, array_e_indlist, array_v_indlist,  &
  &         STAT=ist )
IF (ist /= SUCCESS) THEN
  CALL finish ('mo_model_domain_import:read_patch',  &
    &             'deallocation for array_[cev]_indlist failed')
ENDIF

!
! Set values which are needed for parallel runs
! to the correct values for a single patch owner
!
p_patch%comm   = 0
p_patch%rank   = 0
p_patch%n_proc = 1
p_patch%proc0  = 0

! decomp_domain/owner mask:
! Everywhere 0 or .true. with the exception of unused entries

p_patch%cells%decomp_domain = 0
p_patch%edges%decomp_domain = 0
p_patch%verts%decomp_domain = 0
p_patch%cells%owner_mask = .TRUE.
p_patch%edges%owner_mask = .TRUE.
p_patch%verts%owner_mask = .TRUE.

p_patch%cells%decomp_domain(p_patch%npromz_c+1:nproma,p_patch%nblks_c) = -1
p_patch%edges%decomp_domain(p_patch%npromz_e+1:nproma,p_patch%nblks_e) = -1
p_patch%verts%decomp_domain(p_patch%npromz_v+1:nproma,p_patch%nblks_v) = -1

p_patch%cells%owner_mask(p_patch%npromz_c+1:nproma,p_patch%nblks_c) = .FALSE.
p_patch%edges%owner_mask(p_patch%npromz_e+1:nproma,p_patch%nblks_e) = .FALSE.
p_patch%verts%owner_mask(p_patch%npromz_v+1:nproma,p_patch%nblks_v) = .FALSE.

! The following arrays are currently never needed for non parallel runs,
! we set them nontheless.

DO jc = 1, p_patch%n_patch_cells
  p_patch%cells%glb_index(jc) = jc
  p_patch%cells%loc_index(jc) = jc
  p_patch%cells%owner_g(jc) = 0
ENDDO

DO je = 1, p_patch%n_patch_edges
  p_patch%edges%glb_index(je) = je
  p_patch%edges%loc_index(je) = je
  p_patch%edges%owner_g(je) = 0
ENDDO

DO jv = 1, p_patch%n_patch_verts
  p_patch%verts%glb_index(jv) = jv
  p_patch%verts%loc_index(jv) = jv
  p_patch%verts%owner_g(jv) = 0
ENDDO

IF (msg_level > 10 ) THEN
  CALL message ('mo_model_domimp_patches:read_patch', 'read_patches finished')
ENDIF

END SUBROUTINE read_patch
!-------------------------------------------------------------------------


!-------------------------------------------------------------------------
!> Allocates all arrays in a patch
!!
!! @par Revision History
!! Initial version (split out from read_patch) Rainer Johanni, Oct. 2010
!!
SUBROUTINE allocate_patch(p_patch)

  TYPE(t_patch), INTENT(INOUT) :: p_patch

  ! Please note: The following variables in the patch MUST already be set:
  ! - nblks_c
  ! - nblks_e
  ! - nblks_v
  ! - n_patch_cells
  ! - n_patch_edges
  ! - n_patch_verts
  ! - n_patch_cells_g
  ! - n_patch_edges_g
  ! - n_patch_verts_g
  ! - global_max_childdom

  p_patch%max_childdom = global_max_childdom
  !
  ! !grid cells
  !
  ALLOCATE( p_patch%cells%idx(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%blk(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%num_edges(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%parent_idx(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%parent_blk(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%child_idx(nproma,p_patch%nblks_c,4) )
  ALLOCATE( p_patch%cells%child_blk(nproma,p_patch%nblks_c,4) )
  ALLOCATE( p_patch%cells%child_id(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%neighbor_idx(nproma,p_patch%nblks_c,i_cell_type) )
  ALLOCATE( p_patch%cells%neighbor_blk(nproma,p_patch%nblks_c,i_cell_type) )
  ALLOCATE( p_patch%cells%edge_idx(nproma,p_patch%nblks_c,i_cell_type) )
  ALLOCATE( p_patch%cells%edge_blk(nproma,p_patch%nblks_c,i_cell_type) )
  ALLOCATE( p_patch%cells%vertex_idx(nproma,p_patch%nblks_c,i_cell_type) )
  ALLOCATE( p_patch%cells%vertex_blk(nproma,p_patch%nblks_c,i_cell_type) )
  ALLOCATE( p_patch%cells%edge_orientation(nproma,p_patch%nblks_c,i_cell_type) )
  ALLOCATE( p_patch%cells%center(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%area(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%f_c(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%refin_ctrl(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%start_idx(min_rlcell:max_rlcell,global_max_childdom) )
  ALLOCATE( p_patch%cells%end_idx(min_rlcell:max_rlcell,global_max_childdom) )
  ALLOCATE( p_patch%cells%start_blk(min_rlcell:max_rlcell,global_max_childdom) )
  ALLOCATE( p_patch%cells%end_blk(min_rlcell:max_rlcell,global_max_childdom) )

  ALLOCATE( p_patch%cells%decomp_domain(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%owner_mask(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%glb_index(p_patch%n_patch_cells) )
  ALLOCATE( p_patch%cells%loc_index(p_patch%n_patch_cells_g) )
  ALLOCATE( p_patch%cells%owner_g(p_patch%n_patch_cells_g))

  !
  ! !grid edges
  !
  ALLOCATE( p_patch%edges%idx(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%blk(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%parent_idx(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%parent_blk(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%child_idx(nproma,p_patch%nblks_e,4) )
  ALLOCATE( p_patch%edges%child_blk(nproma,p_patch%nblks_e,4) )
  ALLOCATE( p_patch%edges%child_id(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%cell_idx(nproma,p_patch%nblks_e,2) )
  ALLOCATE( p_patch%edges%cell_blk(nproma,p_patch%nblks_e,2) )
  ALLOCATE( p_patch%edges%vertex_idx(nproma,p_patch%nblks_e,4) )
  ALLOCATE( p_patch%edges%vertex_blk(nproma,p_patch%nblks_e,4) )
  ALLOCATE( p_patch%edges%system_orientation(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%quad_idx(nproma,p_patch%nblks_e,4) )
  ALLOCATE( p_patch%edges%quad_blk(nproma,p_patch%nblks_e,4) )
  ALLOCATE( p_patch%edges%quad_orientation(nproma,p_patch%nblks_e,4) )
  ALLOCATE( p_patch%edges%center(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%primal_normal(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%primal_cart_normal(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%dual_normal(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%dual_cart_normal(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%primal_normal_cell(nproma,p_patch%nblks_e,2) )
  ALLOCATE( p_patch%edges%dual_normal_cell(nproma,p_patch%nblks_e,2) )
  ALLOCATE( p_patch%edges%primal_normal_vert(nproma,p_patch%nblks_e,4) )
  ALLOCATE( p_patch%edges%dual_normal_vert(nproma,p_patch%nblks_e,4) )
  ALLOCATE( p_patch%edges%primal_edge_length(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%inv_primal_edge_length(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%dual_edge_length(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%inv_dual_edge_length(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%edge_vert_length(nproma,p_patch%nblks_e,2) )
  ALLOCATE( p_patch%edges%inv_vert_vert_length(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%edge_cell_length(nproma,p_patch%nblks_e,2) )
  ALLOCATE( p_patch%edges%area_edge(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%quad_area(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%f_e(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%refin_ctrl(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%start_idx(min_rledge:max_rledge,global_max_childdom) )
  ALLOCATE( p_patch%edges%end_idx(min_rledge:max_rledge,global_max_childdom) )
  ALLOCATE( p_patch%edges%start_blk(min_rledge:max_rledge,global_max_childdom) )
  ALLOCATE( p_patch%edges%end_blk(min_rledge:max_rledge,global_max_childdom) )

  ALLOCATE( p_patch%edges%decomp_domain(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%owner_mask(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%glb_index(p_patch%n_patch_edges) )
  ALLOCATE( p_patch%edges%loc_index(p_patch%n_patch_edges_g) )
  ALLOCATE( p_patch%edges%owner_g(p_patch%n_patch_edges_g))

  !
  ! !grid verts
  !
  ALLOCATE( p_patch%verts%idx(nproma,p_patch%nblks_v) )
  ALLOCATE( p_patch%verts%blk(nproma,p_patch%nblks_v) )
  ALLOCATE( p_patch%verts%neighbor_idx(nproma,p_patch%nblks_v,9-i_cell_type) )
  ALLOCATE( p_patch%verts%neighbor_blk(nproma,p_patch%nblks_v,9-i_cell_type) )
  ALLOCATE( p_patch%verts%cell_idx(nproma,p_patch%nblks_v,9-i_cell_type) )
  ALLOCATE( p_patch%verts%cell_blk(nproma,p_patch%nblks_v,9-i_cell_type) )
  ALLOCATE( p_patch%verts%edge_idx(nproma,p_patch%nblks_v,9-i_cell_type) )
  ALLOCATE( p_patch%verts%edge_blk(nproma,p_patch%nblks_v,9-i_cell_type) )
  ALLOCATE( p_patch%verts%edge_orientation(nproma,p_patch%nblks_v,9-i_cell_type) )
  ALLOCATE( p_patch%verts%num_edges(nproma,p_patch%nblks_v) )
  ALLOCATE( p_patch%verts%vertex(nproma,p_patch%nblks_v) )
  ALLOCATE( p_patch%verts%dual_area(nproma,p_patch%nblks_v) )
  ALLOCATE( p_patch%verts%f_v(nproma,p_patch%nblks_v) )
  ALLOCATE( p_patch%verts%refin_ctrl(nproma,p_patch%nblks_v) )
  ALLOCATE( p_patch%verts%start_idx(min_rlvert:max_rlvert,global_max_childdom) )
  ALLOCATE( p_patch%verts%end_idx(min_rlvert:max_rlvert,global_max_childdom) )
  ALLOCATE( p_patch%verts%start_blk(min_rlvert:max_rlvert,global_max_childdom) )
  ALLOCATE( p_patch%verts%end_blk(min_rlvert:max_rlvert,global_max_childdom) )

  ALLOCATE( p_patch%verts%decomp_domain(nproma,p_patch%nblks_v) )
  ALLOCATE( p_patch%verts%owner_mask(nproma,p_patch%nblks_v) )
  ALLOCATE( p_patch%verts%glb_index(p_patch%n_patch_verts) )
  ALLOCATE( p_patch%verts%loc_index(p_patch%n_patch_verts_g) )
  ALLOCATE( p_patch%verts%owner_g(p_patch%n_patch_verts_g))

END SUBROUTINE allocate_patch




!-------------------------------------------------------------------------
  SUBROUTINE destruct_patch( p_patch )

    TYPE(t_patch), TARGET, INTENT(inout) :: p_patch

    CHARACTER(len=MAX_CHAR_LENGTH), PARAMETER :: &
    &        routine = 'mo_model_domimp_patches:destruct_patches'

!local variables
INTEGER :: jg, ist
!-----------------------------------------------------------------------

    IF (msg_level > 10) CALL message (TRIM(routine), 'start')

  !
  ! DEALLOCATE EXTERNAL DATA
  !
  !
  ! Deallocate grid information
  !
  ! CELLS
  DEALLOCATE( p_patch%cells%idx,  &
    &         p_patch%cells%blk,  &
    &         p_patch%cells%num_edges,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell index failed')
  ENDIF
  DEALLOCATE( p_patch%cells%parent_idx,  &
    &         p_patch%cells%parent_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell parent index failed')
  ENDIF
  DEALLOCATE( p_patch%cells%child_idx,  &
    &         p_patch%cells%child_blk,  &
    &         p_patch%cells%child_id,   &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell child index failed')
  ENDIF
  DEALLOCATE( p_patch%cells%neighbor_idx,  &
    &         p_patch%cells%neighbor_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell neighbor index failed')
  ENDIF
  DEALLOCATE( p_patch%cells%edge_idx,  &
    &         p_patch%cells%edge_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell edge index failed')
  ENDIF
  DEALLOCATE( p_patch%cells%vertex_idx,  &
    &         p_patch%cells%vertex_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell vertex index failed')
  ENDIF
  DEALLOCATE( p_patch%cells%edge_orientation,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell edge_orientation failed')
  ENDIF
  DEALLOCATE( p_patch%cells%center,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell center failed')
  ENDIF
  DEALLOCATE( p_patch%cells%area,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell area failed')
  ENDIF
  DEALLOCATE( p_patch%cells%f_c,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell f_c failed')
  ENDIF
  DEALLOCATE( p_patch%cells%refin_ctrl,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell refin_ctrl failed')
  ENDIF
  DEALLOCATE( p_patch%cells%start_idx,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell start_idx failed')
  ENDIF
  DEALLOCATE( p_patch%cells%end_idx,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell end_idx failed')
  ENDIF
  DEALLOCATE( p_patch%cells%start_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell start_blk failed')
  ENDIF
  DEALLOCATE( p_patch%cells%end_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell end_blk failed')
  ENDIF
  DEALLOCATE( p_patch%cells%decomp_domain,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell decomp_domain failed')
  ENDIF
  DEALLOCATE( p_patch%cells%owner_mask,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell owner_mask failed')
  ENDIF
  DEALLOCATE( p_patch%cells%glb_index,  &
    &         p_patch%cells%loc_index,  &
    &         p_patch%cells%owner_g,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell data failed')
  ENDIF
  !
  !
  ! EDGES
  DEALLOCATE( p_patch%edges%idx,  &
    &         p_patch%edges%blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge index failed')
  ENDIF
  DEALLOCATE( p_patch%edges%parent_idx,  &
    &         p_patch%edges%parent_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge parent index failed')
  ENDIF
  DEALLOCATE( p_patch%edges%child_idx,  &
    &         p_patch%edges%child_blk,  &
    &         p_patch%edges%child_id,   &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge child index failed')
  ENDIF
  DEALLOCATE( p_patch%edges%cell_idx,  &
    &         p_patch%edges%cell_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge cell index failed')
  ENDIF
  DEALLOCATE( p_patch%edges%vertex_idx,  &
    &         p_patch%edges%vertex_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge vertex index failed')
  ENDIF
  DEALLOCATE( p_patch%edges%system_orientation,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge system orientation failed')
  ENDIF
  DEALLOCATE( p_patch%edges%quad_idx,  &
    &         p_patch%edges%quad_blk,  &
    &         STAT=ist)
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge quad index failed')
  ENDIF
  DEALLOCATE( p_patch%edges%quad_orientation,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge quad orientation failed')
  ENDIF
  DEALLOCATE( p_patch%edges%center,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge center failed')
  ENDIF
  DEALLOCATE( p_patch%edges%primal_normal,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge primal_normal failed')
  ENDIF
  DEALLOCATE( p_patch%edges%primal_cart_normal,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge primal_cart_normal failed')
  ENDIF
  DEALLOCATE( p_patch%edges%dual_normal,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge dual_normal failed')
  ENDIF
  DEALLOCATE( p_patch%edges%dual_cart_normal,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge dual_cart_normal failed')
  ENDIF
  DEALLOCATE( p_patch%edges%primal_normal_cell,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge primal_normal_cell failed')
  ENDIF
  DEALLOCATE( p_patch%edges%dual_normal_cell,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge dual_normal_cell failed')
  ENDIF
  DEALLOCATE( p_patch%edges%primal_normal_vert,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge primal_normal_vert failed')
  ENDIF
  DEALLOCATE( p_patch%edges%dual_normal_vert,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge dual_normal_vert failed')
  ENDIF
  DEALLOCATE( p_patch%edges%primal_edge_length,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge primal edge length failed')
  ENDIF
  DEALLOCATE( p_patch%edges%inv_primal_edge_length,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for inverse patch edge primal edge length failed')
  ENDIF
  DEALLOCATE( p_patch%edges%dual_edge_length,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge dual edge length failed')
  ENDIF
  DEALLOCATE( p_patch%edges%inv_dual_edge_length,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for inverse patch edge dual edge length failed')
  ENDIF
  DEALLOCATE( p_patch%edges%edge_vert_length,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for edge_vert_length failed')
  ENDIF
  DEALLOCATE( p_patch%edges%inv_vert_vert_length,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for inverse vert_vert_length failed')
  ENDIF
  DEALLOCATE( p_patch%edges%edge_cell_length,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for edge_cell_length failed')
  ENDIF
  DEALLOCATE( p_patch%edges%area_edge,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge area_edge failed')
  ENDIF
  DEALLOCATE( p_patch%edges%quad_area,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge quad area failed')
  ENDIF
  DEALLOCATE( p_patch%edges%f_e,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge f_e failed')
  ENDIF
  DEALLOCATE( p_patch%edges%refin_ctrl,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge refin_ctrl failed')
  ENDIF
  DEALLOCATE( p_patch%edges%start_idx,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge start_idx failed')
  ENDIF
  DEALLOCATE( p_patch%edges%end_idx,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge end_idx failed')
  ENDIF
  DEALLOCATE( p_patch%edges%start_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge start_blk failed')
  ENDIF
  DEALLOCATE( p_patch%edges%end_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge end_blk failed')
  ENDIF
  DEALLOCATE( p_patch%edges%decomp_domain,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge decomp_domain failed')
  ENDIF
  DEALLOCATE( p_patch%edges%owner_mask,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge owner_mask failed')
  ENDIF
  DEALLOCATE( p_patch%edges%glb_index,  &
    &         p_patch%edges%loc_index,  &
    &         p_patch%edges%owner_g,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge data failed')
  ENDIF
  !
  !
  ! VERTICES
  DEALLOCATE( p_patch%verts%idx,  &
    &         p_patch%verts%blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex index failed')
  ENDIF
  DEALLOCATE( p_patch%verts%neighbor_idx,  &
    &         p_patch%verts%neighbor_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex neighbor index failed')
  ENDIF
  DEALLOCATE( p_patch%verts%cell_idx,  &
    &         p_patch%verts%cell_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex cell index failed')
  ENDIF
  DEALLOCATE( p_patch%verts%edge_idx,  &
    &         p_patch%verts%edge_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex edge index failed')
  ENDIF
  DEALLOCATE( p_patch%verts%edge_orientation,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex edge orientation failed')
  ENDIF
  DEALLOCATE( p_patch%verts%num_edges,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex number of edges failed')
  ENDIF
  DEALLOCATE( p_patch%verts%vertex,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex vertex failed')
  ENDIF
  DEALLOCATE( p_patch%verts%dual_area,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex dual area failed')
  ENDIF
  DEALLOCATE( p_patch%verts%f_v,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex f_v failed')
  ENDIF
  DEALLOCATE( p_patch%verts%refin_ctrl,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex edge refin_ctrl failed')
  ENDIF
  DEALLOCATE( p_patch%verts%start_idx,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex edge start_idx failed')
  ENDIF
  DEALLOCATE( p_patch%verts%end_idx,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex edge end_idx failed')
  ENDIF
  DEALLOCATE( p_patch%verts%start_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex edge start_blk failed')
  ENDIF
  DEALLOCATE( p_patch%verts%end_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex edge end_blk failed')
  ENDIF
  DEALLOCATE( p_patch%verts%decomp_domain,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vert decomp_domain failed')
  ENDIF
  DEALLOCATE( p_patch%verts%owner_mask,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vert owner_mask failed')
  ENDIF
  DEALLOCATE( p_patch%verts%glb_index,  &
    &         p_patch%verts%loc_index,  &
    &         p_patch%verts%owner_g,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vert data failed')
  ENDIF

  IF (msg_level > 10) &
    CALL message (routine, 'destruct_patches finished')

END SUBROUTINE destruct_patch


!-------------------------------------------------------------------------

SUBROUTINE nf(status)

INTEGER, INTENT(in) :: status

IF (status /= nf_noerr) THEN
  CALL finish('mo_model_domain_import netCDF error', nf_strerror(status))
ENDIF

END SUBROUTINE nf


END MODULE mo_model_domain_import
